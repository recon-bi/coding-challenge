// this is basic setup of interpolated data
import bcrypt from 'bcrypt';
import dayjs from 'dayjs';
import MongoDbClient from './classes/MongoDbClient';
import apiConfig from './config/db';
import errorHandler from './errorHandler';
import { getRandomArbitrary } from './lib/numbers';
import { hotels } from './mockData/hotels';
import { users } from './mockData/users';
import { IHotel } from './types/hotel';
import { IUserDocument } from './types/userDocument';
import { IUserType } from './types/user';

// this gets the mongodb client
const getClient = async () => {
  try {
    const mongoInstance = MongoDbClient.getInstance();
    if (mongoInstance.isConnected) return mongoInstance.client;
    const client = mongoInstance.connect();
    return client;
  } catch (error) {
    console.error(error);
  }
};

// this transform the data generated by generatedata.com into our hotel object
const transformHotel = async (doc: IHotel) => {
  try {
    const loc = { type: 'point', coordinates: [Number(doc.long), Number(doc.lat)] };
    const imageUrl = `hotel${getRandomArbitrary(1, 10, true)}`;
    const name = `${doc.name} ${doc.city} Inn`;
    return {
      ...doc,
      ...{ name, loc, imageUrl },
    };
  } catch (error) {
    errorHandler(error);
  }
};

const transformUser = async (doc: IUserDocument) => {
  const password = await bcrypt.hash('12345', 10);
  return { ...doc, ...{ password } };
};

const imports = {
  hotels: {
    data: hotels,
    transformer: transformHotel,
  },

  users: {
    data: users,
    transformer: transformUser,
  },
};

const transformBooking = async () => {
  try {
    const duration = 7;
    const checkIn = new Date(
      dayjs()
        .add(Number(getRandomArbitrary(7, 28)), 'days')
        .toISOString(),
    );
    const checkOut = new Date(dayjs(checkIn).add(duration, 'days').toISOString());
    const user = users[2];

    const mongoClient = await getClient();
    const hotels = await mongoClient
      .db(apiConfig.mongoConfig.dbName)
      .collection('hotels')
      .find()
      .skip(getRandomArbitrary(0, 99))
      .limit(1)
      .toArray();

    const hotel = hotels[0];
    const totalPrice = hotel.price * duration;
    return {
      duration,
      checkIn,
      checkOut,
      totalPrice,
      user,
      hotel,
    };
  } catch (error) {
    errorHandler(error);
  }
};

const getPromiseRoot = async (collection: any, key: string) => {
  try {
    const docCount = await collection.countDocuments();
    if (docCount === 0) {
      const { data, transformer } = imports[key];
      const promises = data.map(await transformer);
      const docs = await Promise.all(promises);
      return await collection.insertMany(docs);
    } else {
      return null;
    }
  } catch (error) {
    return { error };
  }
};

export const setup = async () => {
  try {
    const mongoClient = await getClient();
    const db = mongoClient.db(apiConfig.mongoConfig.dbName);
    const promiseRoot = Object.keys(imports).map(async (key: string) => {
      const collection = db.collection(key);
      return await getPromiseRoot(collection, key);
    });
    const status = await Promise.all(promiseRoot);

    if (status.every((x: any) => (x ? !x.error : true))) {
      const bookingDocCount = await db.collection('bookings').countDocuments();
      if (bookingDocCount === 0) {
        const bookingPromises = [...Array(12)].map(transformBooking);
        const docs = await Promise.all(bookingPromises);
        return await db.collection('bookings').insertMany(docs);
      }
    }
  } catch (error) {
    console.log(error);
  }
};
